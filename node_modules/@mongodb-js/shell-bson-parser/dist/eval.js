"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeAST = void 0;
const scope_1 = require("./scope");
const unaryExpression = (node) => {
    if (!node.prefix)
        throw new Error('Malformed UnaryExpression');
    switch (node.operator) {
        case '-':
            return -walk(node.argument);
        case '+':
            return +walk(node.argument);
        case '!':
            return !walk(node.argument);
        case '~':
            return ~walk(node.argument);
        default:
            throw new Error(`Invalid UnaryExpression Provided: '${node.operator}'`);
    }
};
const binaryExpression = (node) => {
    const { left, right } = node;
    switch (node.operator) {
        case '==':
            return walk(left) == walk(right);
        case '!=':
            return walk(left) != walk(right);
        case '===':
            return walk(left) === walk(right);
        case '!==':
            return walk(left) !== walk(right);
        case '<':
            return walk(left) < walk(right);
        case '<=':
            return walk(left) <= walk(right);
        case '>':
            return walk(left) > walk(right);
        case '>=':
            return walk(left) >= walk(right);
        case '<<':
            return walk(left) << walk(right);
        case '>>':
            return walk(left) >> walk(right);
        case '>>>':
            return walk(left) >>> walk(right);
        case '+':
            return walk(left) + walk(right);
        case '-':
            return walk(left) - walk(right);
        case '*':
            return walk(left) * walk(right);
        case '/':
            return walk(left) / walk(right);
        case '%':
            return walk(left) % walk(right);
        case '**':
            return walk(left) ** walk(right);
        case '|':
            return walk(left) | walk(right);
        case '^':
            return walk(left) ^ walk(right);
        case '&':
            return walk(left) & walk(right);
        case 'in':
            return walk(left) in walk(right);
        case 'instanceof':
            return walk(left) instanceof walk(right);
        default:
            throw new Error(`Invalid BinaryExpression Provided: '${String(node.operator)}'`);
    }
};
const memberExpression = (node, withNew) => {
    switch (node.callee.type) {
        case 'Identifier': {
            const callee = (0, scope_1.getScopeFunction)(node.callee.name, withNew);
            const args = node.arguments.map((arg) => walk(arg));
            return callee.apply(callee, args);
        }
        case 'MemberExpression': {
            const calleeThis = node.callee.object.type === 'Identifier'
                ? (0, scope_1.getClass)(node.callee.object.name)
                : walk(node.callee.object);
            const calleeFn = node.callee.property.type === 'Identifier' && node.callee.property.name;
            if (!calleeFn)
                throw new Error('Expected CallExpression property to be an identifier');
            const args = node.arguments.map((arg) => walk(arg));
            return calleeThis[calleeFn](...args);
        }
        default:
            throw new Error('Should not evaluate invalid expressions');
    }
};
const functionExpression = (node) => {
    const source = node.loc?.source || '';
    const range = node.range || [];
    return source.slice(range[0], range[1]);
};
const walk = (node) => {
    switch (node?.type) {
        case 'Identifier':
            if (Object.prototype.hasOwnProperty.call(scope_1.GLOBALS, node.name)) {
                return scope_1.GLOBALS[node.name];
            }
            throw new Error(`${node.name} is not a valid Identifier`);
        case 'Literal':
            return node.value;
        case 'UnaryExpression':
            return unaryExpression(node);
        case 'BinaryExpression':
            return binaryExpression(node);
        case 'ArrayExpression':
            return node.elements.map((node) => walk(node));
        case 'CallExpression':
            return memberExpression(node, false);
        case 'NewExpression':
            return memberExpression(node, true);
        case 'ObjectExpression': {
            const obj = Object.create(null);
            for (const property of node.properties) {
                if (!('key' in property))
                    continue;
                const key = property.key.type === 'Identifier'
                    ? property.key.name
                    : walk(property.key);
                obj[key] = walk(property.value);
            }
            return { ...obj };
        }
        case 'FunctionExpression':
        case 'ArrowFunctionExpression':
            return functionExpression(node);
        default:
            throw new Error();
    }
};
const executeAST = (node) => {
    if (node.type === 'Program') {
        if (node.body.length === 1 && node.body[0].type === 'ExpressionStatement') {
            return walk(node.body[0].expression);
        }
    }
    throw new Error('Invalid AST Found');
};
exports.executeAST = executeAST;
//# sourceMappingURL=eval.js.map