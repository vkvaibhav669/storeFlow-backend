"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLOBAL_FUNCTIONS = exports.GLOBALS = void 0;
exports.getScopeFunction = getScopeFunction;
exports.isMethodWhitelisted = isMethodWhitelisted;
exports.getClass = getClass;
const bson = __importStar(require("bson"));
function lookupMap(input) {
    return Object.freeze(Object.create(null, Object.getOwnPropertyDescriptors(input)));
}
function NumberLong(v) {
    if (typeof v === 'string') {
        return bson.Long.fromString(v);
    }
    else {
        return bson.Long.fromNumber(v);
    }
}
const SCOPE_CALL = lookupMap({
    Date: function (...args) {
        return Date(...args);
    },
});
const SCOPE_NEW = lookupMap({
    Date: function (...args) {
        return new Date(...args);
    },
});
const SCOPE_ANY = lookupMap({
    RegExp: RegExp,
    Binary: function (buffer, subType) {
        return new bson.Binary(buffer, subType);
    },
    BinData: function (t, d) {
        return new bson.Binary(Buffer.from(d, 'base64'), t);
    },
    UUID: function (u) {
        if (u === undefined) {
            return new bson.UUID().toBinary();
        }
        return new bson.Binary(Buffer.from(u.replace(/-/g, ''), 'hex'), 4);
    },
    Code: function (c, s) {
        return new bson.Code(c, s);
    },
    DBRef: function (namespace, oid, db, fields) {
        return new bson.DBRef(namespace, oid, db, fields);
    },
    Decimal128: function (s) {
        return bson.Decimal128.fromString(s);
    },
    NumberDecimal: function (s) {
        return bson.Decimal128.fromString(s);
    },
    Double: function (s) {
        return new bson.Double(s);
    },
    Int32: function (i) {
        return new bson.Int32(i);
    },
    NumberInt: function (s) {
        return new bson.Int32(s);
    },
    Long: function (low, high) {
        return new bson.Long(low, high);
    },
    NumberLong: NumberLong,
    Int64: NumberLong,
    Map: function (arr) {
        return new (bson.Map ?? Map)(arr);
    },
    MaxKey: function () {
        return new bson.MaxKey();
    },
    MinKey: function () {
        return new bson.MinKey();
    },
    ObjectID: function (i) {
        return new bson.ObjectId(i);
    },
    ObjectId: function (i) {
        return new bson.ObjectId(i);
    },
    Symbol: function (i) {
        return new bson.BSONSymbol(i);
    },
    Timestamp: function (low, high) {
        if ((typeof low === 'number' && typeof high === 'number') ||
            high !== undefined) {
            return new bson.Timestamp({ t: low, i: high });
        }
        return new bson.Timestamp(low);
    },
    ISODate: function (input) {
        if (input === undefined)
            return new Date();
        if (typeof input !== 'string')
            return new Date(input);
        const isoDateRegex = /^(?<Y>\d{4})-?(?<M>\d{2})-?(?<D>\d{2})([T ](?<h>\d{2})(:?(?<m>\d{2})(:?((?<s>\d{2})(\.(?<ms>\d+))?))?)?(?<tz>Z|([+-])(\d{2}):?(\d{2})?)?)?$/;
        const match = input.match(isoDateRegex);
        if (match !== null && match.groups !== undefined) {
            const { Y, M, D, h, m, s, ms, tz } = match.groups;
            const normalized = `${Y}-${M}-${D}T${h || '00'}:${m || '00'}:${s || '00'}.${ms || '000'}${tz || 'Z'}`;
            const date = new Date(normalized);
            if (date.getTime() >= -62167219200000 &&
                date.getTime() <= 253402300799999) {
                return date;
            }
        }
        throw new Error(`${JSON.stringify(input)} is not a valid ISODate`);
    },
});
exports.GLOBALS = lookupMap({
    Infinity: Infinity,
    NaN: NaN,
    undefined: undefined,
});
const ALLOWED_CLASS_EXPRESSIONS = lookupMap({
    Math: lookupMap({
        class: Math,
        allowedMethods: lookupMap({
            abs: true,
            acos: true,
            acosh: true,
            asin: true,
            asinh: true,
            atan: true,
            atan2: true,
            atanh: true,
            cbrt: true,
            ceil: true,
            clz32: true,
            cos: true,
            cosh: true,
            exp: true,
            expm1: true,
            floor: true,
            fround: true,
            hypot: true,
            imul: true,
            log: true,
            log10: true,
            log1p: true,
            log2: true,
            max: true,
            min: true,
            pow: true,
            round: true,
            sign: true,
            sin: true,
            sinh: true,
            sqrt: true,
            tan: true,
            tanh: true,
            trunc: true,
        }),
    }),
    Date: lookupMap({
        class: Date,
        allowedMethods: lookupMap({
            getDate: true,
            getDay: true,
            getFullYear: true,
            getHours: true,
            getMilliseconds: true,
            getMinutes: true,
            getMonth: true,
            getSeconds: true,
            getTime: true,
            getTimezoneOffset: true,
            getUTCDate: true,
            getUTCDay: true,
            getUTCFullYear: true,
            getUTCHours: true,
            getUTCMilliseconds: true,
            getUTCMinutes: true,
            getUTCMonth: true,
            getUTCSeconds: true,
            getYear: true,
            now: true,
            setDate: true,
            setFullYear: true,
            setHours: true,
            setMilliseconds: true,
            setMinutes: true,
            setMonth: true,
            setSeconds: true,
            setTime: true,
            setUTCDate: true,
            setUTCFullYear: true,
            setUTCHours: true,
            setUTCMilliseconds: true,
            setUTCMinutes: true,
            setUTCMonth: true,
            setUTCSeconds: true,
            setYear: true,
            toISOString: true,
            valueOf: true,
        }),
    }),
    ISODate: lookupMap({
        class: Date,
        allowedMethods: 'Date',
    }),
    Binary: lookupMap({
        class: bson.Binary,
        allowedMethods: {
            createFromHexString: true,
            createFromBase64: true,
        },
    }),
});
exports.GLOBAL_FUNCTIONS = Object.freeze([
    ...Object.keys(SCOPE_ANY),
    ...Object.keys(SCOPE_NEW),
    ...Object.keys(SCOPE_CALL),
]);
function getScopeFunction(key, withNew) {
    if (withNew && SCOPE_NEW[key]) {
        return SCOPE_NEW[key];
    }
    else if (!withNew && SCOPE_CALL[key]) {
        return SCOPE_CALL[key];
    }
    else if (SCOPE_ANY[key]) {
        return SCOPE_ANY[key];
    }
    throw new Error(`Attempted to access scope property '${key}' that doesn't exist`);
}
function isMethodWhitelisted(member, property) {
    if (Object.prototype.hasOwnProperty.call(ALLOWED_CLASS_EXPRESSIONS, member)) {
        const allowedMethods = ALLOWED_CLASS_EXPRESSIONS[member].allowedMethods;
        if (typeof allowedMethods === 'string') {
            return ALLOWED_CLASS_EXPRESSIONS[allowedMethods]
                .allowedMethods[property];
        }
        return allowedMethods[property];
    }
    return false;
}
function getClass(member) {
    if (Object.prototype.hasOwnProperty.call(ALLOWED_CLASS_EXPRESSIONS, member)) {
        return ALLOWED_CLASS_EXPRESSIONS[member].class;
    }
    throw new Error(`Attempted to access member '${member}' that doesn't exist`);
}
//# sourceMappingURL=scope.js.map