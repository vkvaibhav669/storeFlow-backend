"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkTree = void 0;
const scope_1 = require("./scope");
class Checker {
    constructor(options) {
        this.options = options;
        this.checkSafeCall = (node) => {
            const allowMethods = this.options.allowMethods;
            if (node.callee.type === 'Identifier') {
                return (scope_1.GLOBAL_FUNCTIONS.indexOf(node.callee.name) >= 0 &&
                    node.arguments.every(this.checkSafeExpression));
            }
            if (allowMethods) {
                if (node.callee.type === 'MemberExpression') {
                    const object = node.callee.object;
                    const property = node.callee.property;
                    if (object.type === 'Identifier' && property.type === 'Identifier') {
                        return ((0, scope_1.isMethodWhitelisted)(object.name, property.name) &&
                            node.arguments.every(this.checkSafeExpression));
                    }
                    else if ((object.type === 'NewExpression' ||
                        object.type === 'CallExpression') &&
                        object.callee.type === 'Identifier') {
                        const callee = object.callee;
                        return ((0, scope_1.isMethodWhitelisted)(callee.name, property.name) &&
                            node.arguments.every(this.checkSafeExpression));
                    }
                    else {
                        return (this.checkSafeExpression(object) &&
                            node.arguments.every(this.checkSafeExpression));
                    }
                }
            }
            return false;
        };
        this.checkSafeExpression = (node) => {
            switch (node?.type) {
                case 'Identifier':
                    return Object.prototype.hasOwnProperty.call(scope_1.GLOBALS, node.name);
                case 'Literal':
                    return true;
                case 'ArrayExpression':
                    return node.elements.every(this.checkSafeExpression);
                case 'UnaryExpression':
                    return this.checkSafeExpression(node.argument);
                case 'BinaryExpression':
                    return (this.checkSafeExpression(node.left) &&
                        this.checkSafeExpression(node.right));
                case 'CallExpression':
                case 'NewExpression':
                    return this.checkSafeCall(node);
                case 'ObjectExpression':
                    return node.properties.every((property) => {
                        if (('computed' in property && property.computed) ||
                            ('method' in property && property.method))
                            return false;
                        if (!('key' in property) ||
                            !['Literal', 'Identifier'].includes(property.key.type))
                            return false;
                        return ('value' in property &&
                            (['FunctionExpression', 'ArrowFunctionExpression'].includes(property.value.type) ||
                                this.checkSafeExpression(property.value)));
                    });
                default:
                    return false;
            }
        };
    }
}
const checkTree = (node, options) => {
    if (node.type === 'Program') {
        if (node.body.length === 1 && node.body[0].type === 'ExpressionStatement') {
            const checker = new Checker(options);
            return checker.checkSafeExpression(node.body[0].expression);
        }
    }
    return false;
};
exports.checkTree = checkTree;
//# sourceMappingURL=check.js.map